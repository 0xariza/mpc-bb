/**
 * Ingest Exploits Tool
 * ====================
 * 
 * Ingest historical exploit data from various sources.
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { jsonResponse, errorResponse, logger, config } from "../../core/index.js";
import { ingestExploits, type ExploitRecord } from "../../services/knowledge.service.js";
import { 
  scanDeFiHackLabs, 
  convertToExploitRecords,
  getExploitStatistics 
} from "../../services/defihacklabs.service.js";
import { 
  scanLearnEVMAttacks,
  convertToExploitRecords as convertLearnEVMAttacks,
} from "../../services/learn-evm-attacks.service.js";
import * as path from "path";

// Curated list of notable DeFi exploits
const KNOWN_EXPLOITS: ExploitRecord[] = [
  {
    id: "exploit-balancer-2023-08",
    name: "Balancer Read-Only Reentrancy",
    protocol: "Balancer",
    date: "2023-08-22",
    loss: "$2,100,000",
    category: "reentrancy",
    description: "Attacker exploited read-only reentrancy in Balancer pools. View functions like getRate() returned manipulated values during callback execution, affecting protocols that used these rates for pricing.",
    attackVector: "Flash loan → Enter pool with callback token → During callback, read manipulated rate → Profit from rate difference in dependent protocols",
    source: "DeFiHackLabs",
  },
  {
    id: "exploit-curve-2023-07",
    name: "Curve Read-Only Reentrancy",
    protocol: "Curve",
    date: "2023-07-30",
    loss: "$70,000,000+",
    category: "reentrancy",
    description: "Multiple Curve pools were drained due to a reentrancy vulnerability in the Vyper compiler. get_virtual_price() was vulnerable during ETH transfers.",
    attackVector: "Flash loan ETH → Add liquidity → During ETH callback, get_virtual_price returns wrong value → Exploit dependent protocols",
    source: "rekt.news",
  },
  {
    id: "exploit-euler-2023-03",
    name: "Euler Finance Flash Loan Attack",
    protocol: "Euler",
    date: "2023-03-13",
    loss: "$197,000,000",
    category: "flash-loan",
    description: "Attacker exploited a vulnerability in Euler's donation and liquidation mechanism. The donateToReserves function allowed creating bad debt that could be liquidated profitably.",
    attackVector: "Flash loan → Create leveraged position → Donate to reserves creating bad debt → Liquidate with profit",
    source: "DeFiHackLabs",
  },
  {
    id: "exploit-beanstalk-2022-04",
    name: "Beanstalk Governance Attack",
    protocol: "Beanstalk",
    date: "2022-04-17",
    loss: "$181,000,000",
    category: "governance",
    description: "Attacker used flash loan to gain enough voting power to pass a malicious governance proposal that drained the protocol.",
    attackVector: "Flash loan tokens → Gain voting power → Submit and pass malicious proposal → Drain funds",
    source: "rekt.news",
  },
  {
    id: "exploit-ronin-2022-03",
    name: "Ronin Bridge Hack",
    protocol: "Ronin",
    date: "2022-03-23",
    loss: "$624,000,000",
    category: "access-control",
    description: "Attacker compromised 5 of 9 validator private keys to forge withdrawals from the Ronin bridge.",
    attackVector: "Social engineering → Compromise validator keys → Forge withdrawal signatures",
    source: "rekt.news",
  },
  {
    id: "exploit-wormhole-2022-02",
    name: "Wormhole Bridge Hack",
    protocol: "Wormhole",
    date: "2022-02-02",
    loss: "$326,000,000",
    category: "signature-verification",
    description: "Attacker exploited a signature verification vulnerability to mint wrapped ETH without depositing collateral.",
    attackVector: "Bypass signature verification → Mint uncollateralized wETH → Bridge to Ethereum",
    source: "DeFiHackLabs",
  },
  {
    id: "exploit-nomad-2022-08",
    name: "Nomad Bridge Hack",
    protocol: "Nomad",
    date: "2022-08-01",
    loss: "$190,000,000",
    category: "improper-validation",
    description: "A routine upgrade accidentally set the trusted root to 0x0, allowing anyone to prove arbitrary messages.",
    attackVector: "Copy valid transaction → Replace recipient → Submit with zero root validation",
    source: "rekt.news",
  },
  {
    id: "exploit-cream-2021-10",
    name: "Cream Finance Oracle Manipulation",
    protocol: "Cream Finance",
    date: "2021-10-27",
    loss: "$130,000,000",
    category: "oracle-manipulation",
    description: "Attacker manipulated the price oracle by flash loaning large amounts and exploiting the yUSD price calculation.",
    attackVector: "Flash loan → Manipulate yUSD price via Yearn vault → Borrow with inflated collateral",
    source: "DeFiHackLabs",
  },
  {
    id: "exploit-compound-2021-09",
    name: "Compound Over-Distribution Bug",
    protocol: "Compound",
    date: "2021-09-30",
    loss: "$80,000,000",
    category: "logic-error",
    description: "A proposal to update the COMP distribution accidentally caused over-distribution of COMP rewards to users.",
    attackVector: "Governance error → Faulty distribution logic → Over-reward claims",
    source: "rekt.news",
  },
  {
    id: "exploit-polynetwork-2021-08",
    name: "Poly Network Cross-Chain Hack",
    protocol: "Poly Network",
    date: "2021-08-10",
    loss: "$611,000,000",
    category: "access-control",
    description: "Attacker exploited a vulnerability in cross-chain message verification to change the keeper address and drain funds.",
    attackVector: "Craft malicious cross-chain message → Change contract keepers → Withdraw all funds",
    source: "DeFiHackLabs",
  },
  {
    id: "exploit-pancakebunny-2021-05",
    name: "PancakeBunny Flash Loan Attack",
    protocol: "PancakeBunny",
    date: "2021-05-19",
    loss: "$45,000,000",
    category: "flash-loan",
    description: "Attacker used flash loans to manipulate PancakeSwap prices and exploit the BUNNY minting mechanism.",
    attackVector: "Flash loan → Manipulate LP price → Mint excess BUNNY → Dump tokens",
    source: "rekt.news",
  },
  {
    id: "exploit-uranium-2021-04",
    name: "Uranium Finance Exploit",
    protocol: "Uranium Finance",
    date: "2021-04-28",
    loss: "$50,000,000",
    category: "logic-error",
    description: "A bug in the balance calculation allowed attackers to drain pairs by exploiting the swap logic.",
    attackVector: "Exploit multiplication error in swap calculation → Drain LP reserves",
    source: "DeFiHackLabs",
  },
  {
    id: "exploit-meerkat-2021-03",
    name: "Meerkat Finance Rug Pull",
    protocol: "Meerkat Finance",
    date: "2021-03-04",
    loss: "$31,000,000",
    category: "rug-pull",
    description: "Developers used a backdoor in the timelock to drain user funds one day after launch.",
    attackVector: "Deploy with backdoor → Attract deposits → Bypass timelock → Drain funds",
    source: "rekt.news",
  },
  {
    id: "exploit-harvest-2020-10",
    name: "Harvest Finance Flash Loan",
    protocol: "Harvest Finance",
    date: "2020-10-26",
    loss: "$34,000,000",
    category: "flash-loan",
    description: "Attacker used flash loans to manipulate the USDC/USDT price in Curve to exploit Harvest's vault pricing.",
    attackVector: "Flash loan → Swap to manipulate Curve price → Deposit/withdraw from Harvest vault at favorable rate",
    source: "DeFiHackLabs",
  },
  {
    id: "exploit-bzx-2020-02",
    name: "bZx Flash Loan Attack",
    protocol: "bZx",
    date: "2020-02-15",
    loss: "$8,000,000",
    category: "flash-loan",
    description: "One of the first major flash loan attacks, exploiting bZx's margin trading through price manipulation.",
    attackVector: "Flash loan → Open leveraged short → Manipulate oracle price → Liquidate at profit",
    source: "rekt.news",
  },
  {
    id: "exploit-dao-2016-06",
    name: "The DAO Hack",
    protocol: "The DAO",
    date: "2016-06-17",
    loss: "$60,000,000",
    category: "reentrancy",
    description: "The first major reentrancy attack in Ethereum history. Attacker recursively called the withdraw function before balance was updated.",
    attackVector: "Call withdraw → During ETH transfer, reenter withdraw → Drain funds before state update",
    source: "historical",
  },
];

/**
 * Register the ingest_exploits tool
 */
export function registerIngestExploits(server: McpServer): void {
  server.tool(
    "ingest_exploits",
    "Ingest historical DeFi exploit data into the knowledge base",
    {
      source: z.enum(["builtin", "defihacklabs", "learn-evm-attacks", "rekt", "all"])
        .optional()
        .default("builtin")
        .describe("Source of exploit data to ingest"),
      customExploits: z.array(z.object({
        id: z.string(),
        name: z.string(),
        protocol: z.string(),
        date: z.string(),
        loss: z.string().optional(),
        category: z.string(),
        description: z.string(),
        attackVector: z.string().optional(),
      })).optional().describe("Custom exploit records to ingest"),
    },
    async ({ source, customExploits }) => {
      try {
        let exploits: ExploitRecord[] = [];
        
        if (source === "builtin" || source === "all") {
          exploits.push(...KNOWN_EXPLOITS);
        }
        
        if (source === "defihacklabs" || source === "all") {
          logger.info("Scanning DeFiHackLabs repository");
          try {
            const defihacklabsPath = path.join(config.paths.root, "resource", "DeFiHackLabs");
            const defihacklabsExploits = scanDeFiHackLabs(defihacklabsPath);
            const exploitRecords = convertToExploitRecords(defihacklabsExploits);
            exploits.push(...exploitRecords);
            
            const stats = getExploitStatistics(defihacklabsExploits);
            logger.info("DeFiHackLabs scan complete", { 
              total: stats.total,
              categories: Object.keys(stats.byCategory).length 
            });
          } catch (e) {
            logger.error("Failed to scan DeFiHackLabs", { error: e });
            // Fallback to builtin if scan fails
            if (source === "defihacklabs") {
              exploits.push(...KNOWN_EXPLOITS.filter(e => e.source === "DeFiHackLabs"));
            }
          }
        }
        
        if (source === "learn-evm-attacks" || source === "all") {
          logger.info("Scanning learn-evm-attacks repository");
          try {
            const learnEvmAttacksPath = path.join(config.paths.root, "resource", "learn-evm-attacks");
            const learnEvmAttacksExploits = scanLearnEVMAttacks(learnEvmAttacksPath);
            const exploitRecords = convertLearnEVMAttacks(learnEvmAttacksExploits);
            exploits.push(...exploitRecords);
            
            logger.info("learn-evm-attacks scan complete", { 
              total: learnEvmAttacksExploits.length,
            });
          } catch (e) {
            logger.error("Failed to scan learn-evm-attacks", { error: e });
            // Continue without failing
          }
        }
        
        if (source === "rekt") {
          logger.info("Rekt.news fetch not implemented, using builtin");
          exploits.push(...KNOWN_EXPLOITS.filter(e => e.source === "rekt.news"));
        }
        
        if (customExploits) {
          exploits.push(...customExploits.map(e => ({
            ...e,
            source: "custom",
          })));
        }
        
        const count = await ingestExploits(exploits);
        
        // Group by category for summary
        const byCategory: Record<string, number> = {};
        for (const exploit of exploits) {
          byCategory[exploit.category] = (byCategory[exploit.category] || 0) + 1;
        }
        
        return jsonResponse({
          success: true,
          message: `Ingested ${count} exploit records`,
          summary: {
            total: count,
            byCategory,
            sources: [...new Set(exploits.map(e => e.source))],
          },
          exploits: exploits.map(e => ({
            id: e.id,
            name: e.name,
            protocol: e.protocol,
            category: e.category,
            loss: e.loss,
          })),
        });
        
      } catch (e) {
        logger.error("Failed to ingest exploits", { error: e });
        return errorResponse("Failed to ingest exploits", { error: String(e) });
      }
    }
  );
}
